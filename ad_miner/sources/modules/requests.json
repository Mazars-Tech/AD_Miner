{
    "delete_orphans" : {
        "name": "Delete orphan objects that have no labels",
        "request": "MATCH (n) WHERE size(labels(n))=1 DETACH DELETE n",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "preparation_request_nodes": {
        "name": "Clean AD Miner custom attributes",
        "request": "MATCH (n) REMOVE n.is_server,n.is_dc,n.is_da,n.is_dag,n.can_dcsync,n.path_candidate,n.ou_candidate,n.contains_da_dc,n.is_da_dc,n.ghost_computer,n.has_path_to_da,n.is_admin,n.is_group_operator,n.nbr_adm_machines,n.members_count,n.has_members,n.user_members_count,n.is_operator_member,n.is_group_account_operator,n.is_group_backup_operator,n.is_group_server_operator,n.is_group_print_operator,n.is_account_operator,n.is_backup_operator,n.is_server_operator,n.is_print_operator,n.gpolinks_count,n.has_links,n.dangerous_inbound, n.is_adminsdholder,n.is_dnsadmin,n.da_types",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "delete_unresolved": {
        "name": "Delete objects for which SID could not resolved",
        "request": "MATCH (n) WHERE (NOT EXISTS(n.domain) AND NOT (n:Domain)) OR NOT EXISTS(n.name) DETACH DELETE n",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_upper_domain_name": {
        "name": "Set domain names to upper case when not the case",
        "request": "MATCH (g) where g.domain <> toUpper(g.domain) SET g.domain=toUpper(g.domain) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "preparation_request_relations": {
        "name": "Clean AD Miner custom relations",
        "request": "MATCH (g:Group)-[r:CanExtractDCSecrets|CanLoadCode|CanLogOnLocallyOnDC]->(c:Computer) DELETE r ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_server": {
        "name": "Set is_server=TRUE to computers for which operatingsystem contains Server)",
        "request": "MATCH (c:Computer)  WHERE c.operatingsystem CONTAINS \"erver\" SET c.is_server=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_non_server": {
        "name": "Set is_server=FALSE to other computers )",
        "request": "MATCH (c:Computer) WHERE c.is_server IS NULL  SET c.is_server=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_dc": {
        "name": "Set dc=TRUE to computers that are domain controllers)",
        "request": "MATCH (c:Computer)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-516\" OR g.objectid ENDS WITH \"-521\"SET c.is_dc=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_nondc": {
        "name": "Set dc=FALSE to computers that are not domain controllers)",
        "request": "MATCH (c:Computer) WHERE c.is_dc IS NULL SET c.is_dc=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_can_extract_dc_secrets": {
        "name": "ADD CanExtractDCSecrets relation from BACKUP OPERATORS OR SERVER OPERATORS groups to DCs of same domain",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-551\" OR g.objectid ENDS WITH \"-549\" MATCH (c:Computer{is_dc:true}) WHERE g.domain = c.domain MERGE (g)-[:CanExtractDCSecrets]->(c) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_unconstrained_delegations": {
        "name": "ADD UnconstrainedDelegations relation from objects with KUD to the corresponding domain",
        "request": "MATCH (m{unconstraineddelegation:true,is_dc:false}) MATCH (d:Domain) WHERE m.domain = d.domain MERGE (m)-[:UnconstrainedDelegations]->(d) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_adminsdholder": {
        "name": "Set is_adminsdholder to Container with AdminSDHOLDER in name",
        "request": "MATCH (c:Container) WHERE c.name STARTS WITH \"ADMINSDHOLDER@\" SET c.is_adminsdholder=true ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_dnsadmin": {
        "name": "Set is_dnsadmin to Group with DNSAdmins in name",
        "request": "MATCH (g:Group) WHERE g.name STARTS WITH \"DNSADMINS@\" SET g.is_dnsadmin=true ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_can_load_code": {
        "name": "ADD CanLoadCode relation from PRINT OPERATORS groups to DCs of same domain",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-550\" MATCH (c:Computer{is_dc:true}) WHERE g.domain = c.domain MERGE (g)-[:CanLoadCode]->(c) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_can_logon_dc": {
        "name": "ADD CanLogOnLocallyOnDC relation from ACCOUNT OPERATORS groups to DCs of same domain",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-548\" MATCH (c:Computer{is_dc:true}) WHERE g.domain = c.domain MERGE (g)-[:CanLogOnLocallyOnDC]->(c) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_da": {
        "name": "Set da=TRUE to users that are domain admins or administrators or enterprise admin",
        "request": "MATCH (c:User)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" SET c.is_da=TRUE, c.da_types=[]",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_da_types": {
        "name": "Set the da type (domain, enterprise, key or builtin)",
        "request": "MATCH (c:User)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" WITH c,g, CASE WHEN g.objectid ENDS WITH \"-512\" THEN \"Domain Admin\" WHEN g.objectid ENDS WITH \"-518\" THEN \"Schema Admin\" WHEN g.objectid ENDS WITH \"-519\" THEN \"Enterprise Admin\" WHEN g.objectid ENDS WITH \"-525\" THEN \"Protected Users\" WHEN g.objectid ENDS WITH \"-526\" THEN \"_ Key Admin\" WHEN g.objectid ENDS WITH \"-527\" THEN \"Enterprise Key Admin\" WHEN g.objectid ENDS WITH \"-544\" THEN \"Builtin Administrator\" ELSE null END AS da_type SET c.da_types = c.da_types + da_type",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "for unknown reasons checking the whole condition has to be checked twice or it doesn't work",
        "_comment2": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_dag": {
        "name": "Set da=TRUE to groups that are domain admins or administrators or enterprise admin",
        "request": "MATCH (c:Group)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" SET c.is_da=TRUE",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"

    },
    "set_dag_types": {
        "name": "Set the da type (domain, enterprise, key or builtin)",
        "request": "MATCH (c:Group)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" WITH c,g, CASE WHEN g.objectid ENDS WITH \"-512\" THEN \"Domain Admin\" WHEN g.objectid ENDS WITH \"-518\" THEN \"Schema Admin\" WHEN g.objectid ENDS WITH \"-519\" THEN \"Enterprise Admin\" WHEN g.objectid ENDS WITH \"-525\" THEN \"Protected Users\" WHEN g.objectid ENDS WITH \"-526\" THEN \"_ Key Admin\" WHEN g.objectid ENDS WITH \"-527\" THEN \"Enterprise Key Admin\" WHEN g.objectid ENDS WITH \"-544\" THEN \"Builtin Administrator\" ELSE null END AS da_type SET c.da_types = c.da_types + da_type",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "for unknown reasons checking the whole condition has to be checked twice or it doesn't work",
        "_comment2": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_dagg": {
        "name": "Set da=TRUE to groups that are domain admins or administrators or enterprise admin",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" SET g.is_da=TRUE",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"

    },
    "set_dagg_types": {
        "name": "Set the da type (domain, enterprise, key or builtin)",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" WITH g, CASE WHEN g.objectid ENDS WITH \"-512\" THEN \"Domain Admin\" WHEN g.objectid ENDS WITH \"-518\" THEN \"Schema Admin\" WHEN g.objectid ENDS WITH \"-519\" THEN \"Enterprise Admin\" WHEN g.objectid ENDS WITH \"-525\" THEN \"Protected Users\" WHEN g.objectid ENDS WITH \"-526\" THEN \"_ Key Admin\" WHEN g.objectid ENDS WITH \"-527\" THEN \"Enterprise Key Admin\" WHEN g.objectid ENDS WITH \"-544\" THEN \"Builtin Administrator\" ELSE null END AS da_type SET g.da_types = g.da_types + da_type",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "for unknown reasons checking the whole condition has to be checked twice or it doesn't work",
        "_comment2": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_daggg": {
        "name": "Set dag=TRUE to the exact domain admin group (end with 512)",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-512\"  SET g.is_dag=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_nonda": {
        "name": "Set is_da=FALSE to all objects that do not have is_da=TRUE",
        "request": "MATCH (c) WHERE c.is_da IS NULL SET c.is_da=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_nondag": {
        "name": "Set is_dag=FALSE to all objects that do not have is_da=TRUE",
        "request": "MATCH (g) WHERE g.is_dag IS NULL SET g.is_dag=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "del_fake_dc_admins": {
        "name": "Delete AdminTo edges from non-DA to DC",
        "request": "MATCH (g{is_da:false})-[rr:AdminTo]->(c:Computer{is_dc:true}) DETACH DELETE rr ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_group_operator": {
        "name": "Set is_group_operator to Operator Groups (cf: ACCOUNT OPERATORS, SERVER OPERATORS, BACKUP OPERATORS, PRINT OPERATORS)",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-551\" OR g.objectid ENDS WITH \"-549\" OR g.objectid ENDS WITH \"-548\" OR g.objectid ENDS WITH \"-550\" SET g.is_group_operator=True SET g.is_group_account_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN true END, g.is_group_backup_operator = CASE WHEN g.objectid ENDS WITH \"-551\" THEN true END, g.is_group_server_operator = CASE WHEN g.objectid ENDS WITH \"-549\" THEN true END, g.is_group_print_operator = CASE WHEN g.objectid ENDS WITH \"-550\" THEN true END ",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "BACKUP OPERATORS ENDS WITH = S-1-5-32-551 | ACCOUNT OPERATORS ENDS WITH =  S-1-5-32-548",
        "_comment_2": "SERVER OPERATORS ENDS WITH = S-1-5-32-549 | PRINT OPERATORS ENDS WITH   = S-1-5-32-550"
    },
    "set_is_operator_member": {
        "name": "Set is_operator_member to objects member of Operator Groups (cf: ACCOUNT OPERATORS, SERVER OPERATORS, BACKUP OPERATORS, PRINT OPERATORS)",
        "request": "MATCH (o:User)-[r:MemberOf*1..5]->(g:Group{is_group_operator:True}) WHERE o.is_da=false OR o.domain <> g.domain SET o.is_operator_member=true SET o.is_account_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN true ELSE o.is_account_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"ACCOUNT OPERATOR\" ELSE o.is_type_operator END, o.is_backup_operator = CASE WHEN g.objectid ENDS WITH \"-551\" THEN true ELSE o.is_backup_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"BACKUP OPERATOR\" ELSE o.is_type_operator END, o.is_server_operator = CASE WHEN g.objectid ENDS WITH \"-549\" THEN true ELSE o.is_server_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"SERVER OPERATOR\" ELSE o.is_type_operator END, o.is_print_operator = CASE WHEN g.objectid ENDS WITH \"-550\" THEN true ELSE o.is_print_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"PRINT OPERATOR\" ELSE o.is_type_operator END ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_dcsync1": {
        "name": "Set dcsync=TRUE to nodes that can DCSync (GetChanges/GetChangesAll)",
        "request": "MATCH p=allShortestPaths((n1)-[:MemberOf|GetChanges*1..5]->(u:Domain)) WHERE n1 <> u WITH n1 MATCH p2=(n1)-[:MemberOf|GetChangesAll*1..5]->(u:Domain) WHERE n1 <> u AND NOT n1.name IS NULL AND (((n1.is_da IS NULL OR n1.is_da=FALSE) AND (n1.is_dc IS NULL OR n1.is_dc=FALSE)) OR (NOT u.domain CONTAINS '.' + n1.domain AND n1.domain <> u.domain)) SET n1.can_dcsync=TRUE RETURN DISTINCT p2 as p",
        "output_type": "Graph",
        "is_a_write_request": "true"
    },
    "set_dcsync2": {
        "name": "Set dcsync=TRUE to nodes that can DCSync (GenericAll/AllExtendedRights)",
        "request": "MATCH p3=allShortestPaths((n2)-[:MemberOf|GenericAll|AllExtendedRights*1..5]->(u:Domain)) WHERE n2 <> u AND NOT n2.name IS NULL AND (((n2.is_da IS NULL OR n2.is_da=FALSE) AND (n2.is_dc IS NULL OR n2.is_dc=FALSE)) OR (NOT u.domain CONTAINS '.' + n2.domain AND n2.domain <> u.domain)) SET n2.can_dcsync=TRUE RETURN DISTINCT p3 as p",
        "output_type": "Graph",
        "is_a_write_request": "true"
    },
    "dcsync_list": {
        "name": "Get list of objects that can DCsync (and should probably not be to)",
        "request": "MATCH (n{can_dcsync:true}) RETURN n.domain as domain, n.name as name",
        "output_type": "dict"
    },
    "set_path_candidate": {
        "name": "Set path_candidate=TRUE to candidates eligible to shortestPath to DA",
        "request": "MATCH (o) WHERE NOT o.name IS NULL AND (o.is_da=false OR o.is_da IS NULL) AND NOT o:Domain AND ((o.enabled=True AND o:User) OR NOT o:User) SET o.path_candidate=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_ou_candidate": {
        "name": "Set ou_candidate=TRUE to candidates eligible to shortestou to DA",
        "request": "MATCH (m) WHERE NOT m.name IS NULL AND ((m:Computer AND (m.is_dc=false OR NOT EXISTS(m.is_dc))) OR (m:User AND (m.is_da=false OR NOT EXISTS(m.is_da)))) SET m.ou_candidate=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_containsda": {
        "name": "Set contains_da_dc=TRUE to all objects that contains a domain administrator",
        "request": "MATCH (o:OU)-[r:Contains*1..]->(x{is_da:true}) SET o.contains_da_dc=true",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_containsdc": {
        "name": "Set contains_da_dc=TRUE to all objects that contains a domain controller",
        "request": "MATCH (o:OU)-[r:Contains*1..]->(x{is_dc:true}) SET o.contains_da_dc=true",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_da_dc": {
        "name": "Set is_da_dc=TRUE to all objects that are domain controller or domain admins",
        "request": "MATCH (u) WHERE (u.is_da=true OR u.is_dc=true) SET u.is_da_dc=true",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_members_count": {
        "name": "Set members_count to groups (recursivity = 5)",
        "request": "MATCH  (g:Group) WITH g ORDER BY g.name SKIP PARAM1 LIMIT PARAM2 MATCH (u:User)-[:MemberOf*1..5]->(g) WHERE NOT u.name IS NULL AND NOT g.name IS NULL WITH g AS g1, count(u) AS memberscount SET g1.members_count=memberscount",
        "output_type": "list",
        "scope_query": "MATCH (g:Group) RETURN count(g)",
        "is_a_write_request": "true",
        "_comment": "Recursivity = 5 seems the good match for ratio results/time when searching MemberOf*1..X when using our servers (else 3)"
    },
    "set_groups_has_members": {
        "name": "Set has_member=True to groups with member, else false ",
        "request": "MATCH (g:Group) SET g.has_members=(CASE WHEN g.members_count>0 THEN TRUE ELSE FALSE END) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_gpo_links_count": {
        "name": "Set the count of links/object where the GPO is applied",
        "request": "MATCH p=(g:GPO)-[:GPLink]->(o) WITH g.name as gponame, count(p) AS gpolinkscount MATCH (g1:GPO) WHERE g1.name=gponame AND gpolinkscount IS NOT NULL SET g1.gpolinks_count=gpolinkscount ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_gpos_has_links": {
        "name": "Set has_links=True to GPOs with links, else false ",
        "request": "MATCH (g:GPO) SET g.has_links=(CASE WHEN g.gpolinks_count>0 THEN TRUE ELSE FALSE END) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_adcs": {
        "name": "Set is_adcs to ADCS servers",
        "request": "MATCH (g:Group) WHERE g.name STARTS WITH 'CERT PUBLISHERS@' MATCH (c:Computer)-[r:MemberOf*1..4]->(g) SET c.is_adcs=TRUE RETURN c.domain AS domain, c.name AS name", 
        "output_type": "dict",
        "is_a_write_request": "true"
    },
    "set_groups_direct_admin": {
        "name": "Set groups which are direct admins of computers",
        "request": "MATCH (g:Group)-[r:AdminTo]->(c:Computer) SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "This block of requests aims at optimizing the path requests by tagging interesting nodes"
    },
    "set_groups_indirect_admin_1": {
        "name": "1 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group)-[r:MemberOf]->(gg:Group{is_admin:true}) SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_indirect_admin_2": {
        "name": "2 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group{is_admin:false})-[r:MemberOf]->(gg:Group{is_admin:true}) SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_indirect_admin_3": {
        "name": "3 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group{is_admin:false})-[r:MemberOf]->(gg:Group{is_admin:true}) SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_indirect_admin_4": {
        "name": "4 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group{is_admin:false})-[r:MemberOf]->(gg:Group{is_admin:true}) SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "nb_domain_collected": {
        "name": "Count number of domains collected",
        "request": "MATCH (m:Domain)-[r]->() RETURN distinct(COALESCE(m.domain, m.name))",
        "output_type": "list"
    },
    "get_count_of_member_admin_group": {
        "name": "Count number of users in group",
        "request": "MATCH (u:User{enabled:true})-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE NOT u.name IS NULL and NOT gg.name IS NULL WITH count(u) as count, gg as g MATCH (g) SET g.user_members_count=count",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "get_users_linked_admin_group": {
        "name": "Returns all users member of an admin group",
        "request": "MATCH (u:User{enabled:true})-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE NOT u.name IS NULL and NOT gg.name IS NULL SET u.is_admin=true RETURN u, gg, ID(u) as idu, ID(gg) as idg",
        "output_type": "dict",
        "is_a_write_request": "true"
    },
    "get_groups_linked_admin_group": {
        "name": "Returns all groups member of an admin group",
        "request": "MATCH (g:Group)-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE NOT g.name IS NULL and NOT gg.name IS NULL RETURN g, gg, ID(g) as idg, ID(gg) as idgg",
        "output_type": "dict"
    },
    "get_computers_linked_admin_group": {
        "name": "Returns all computers administrated by an admin group",
        "request": "MATCH (g:Group{is_admin:true})-[r:AdminTo]->(c:Computer) WHERE NOT c.name IS NULL and NOT g.name IS NULL RETURN g, c, ID(g) as idg, ID(c) as idc",
        "output_type": "dict"
    },
    "get_users_direct_admin": {
        "name": "Return direct admin users",
        "request": "MATCH (g:User{enabled:true})-[r:AdminTo]->(c:Computer) WHERE NOT g.name IS NULL and NOT c.name IS NULL SET g.is_admin=True RETURN g, c, ID(g) as idg, ID(c) as idc",
        "output_type": "dict",
        "is_a_write_request": "true"
    },
    "set_ghost_computer": {
        "name": "Set ghost_computer=TRUE to computers that did not login for more than 90 days",
        "request": "MATCH (n:Computer) WHERE toInteger(($extract_date - n.lastlogontimestamp)/86400)>$password_renewal SET   n.ghost_computer=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "domains": {
        "name": "List of domains",
        "request": "MATCH (m:Domain) RETURN DISTINCT(m.name) AS domain ORDER BY m.name",
        "output_type": "list"
    },
    "nb_domain_controllers": {
        "name": "Number of domain controllers",
        "request": "MATCH (c1:Computer{is_dc:TRUE}) RETURN DISTINCT(c1.domain) AS domain, c1.name AS name, COALESCE(c1.operatingsystem, 'Unknown') AS os, COALESCE(c1.ghost_computer, False) AS ghost",
        "output_type": "dict"
    },
    "domain_OUs": {
        "name": "Domain Organisational Units",
        "request": "MATCH (o:OU)-[:Contains]->(c) RETURN o.name AS OU, c.name AS name",
        "output_type": "dict"
    },
    "users_shadow_credentials": {
        "name": "Non privileged users that can impersonate privileged users",
        "request": "MATCH (u:User{enabled:true,is_da:false}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH p=allShortestPaths((u)-[r:MemberOf|AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl*1..3]->(m:User{is_da:true,enabled:true})) RETURN p ",
        "scope_query": "MATCH (u:User{is_da:false, enabled:true}) return count(u)",
        "output_type": "Graph"
    },
    "users_shadow_credentials_to_non_admins": {
        "name": "Non privileged users that can be impersonated by non privileged users",
        "request": "CALL {MATCH (u:User{enabled:true,is_da:false}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((u)-[r:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl*1..3]->(m:User{enabled:true})) WHERE u<>m RETURN p UNION ALL MATCH (g:Group{is_dag:false,is_da:false})  WITH g ORDER BY g.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((g:Group{is_dag:false,is_da:false})-[r3:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl*1..3]->(m:User{enabled:true})) RETURN p} RETURN distinct p",
        "scope_query": "MATCH (u:User {enabled:true, is_da:false}) WITH count(u) AS user_count MATCH (g:Group {is_dag:false, is_da:false}) WITH user_count, count(g) AS group_count RETURN CASE WHEN user_count > group_count THEN user_count ELSE group_count END AS max_count",
        "output_type": "Graph"
    },
    "nb_enabled_accounts": {
        "name": "Number of domain accounts enabled",
        "request": "MATCH p=(u:User{enabled:true} ) RETURN DISTINCT(u.domain) AS domain, u.name AS name, toInteger(($extract_date - u.lastlogontimestamp)/86400) AS logon ORDER BY u.domain",
        "output_type": "dict"
    },
    "nb_groups": {
        "name": "Number of groups",
        "request": "MATCH p=(g:Group) WHERE NOT g.name IS NULL AND NOT g.domain IS NULL RETURN DISTINCT(g.domain) AS domain, g.name AS name, g.is_da AS da ORDER BY g.domain",
        "output_type": "dict"
    },
    "nb_computers": {
        "name": "Number of computers",
        "request": "MATCH (c:Computer) WHERE NOT c.name IS NULL RETURN DISTINCT(c.domain) AS domain, c.name AS name, c.operatingsystem AS os, c.ghost_computer AS ghost ORDER BY c.domain",
        "output_type": "dict"
    },
    "computers_not_connected_since": {
        "name": "Computers not connected since",
        "request": "MATCH (c:Computer) WHERE NOT c.lastlogontimestamp IS NULL AND c.name IS NOT NULL RETURN c.name AS name, toInteger(($extract_date - c.lastlogontimestamp)/86400) as days, toInteger(($extract_date - c.pwdlastset)/86400) as pwdlastset, c.enabled as enabled ORDER BY days DESC ",
        "output_type": "dict"
    },
    "nb_domain_admins": {
        "name": "Number of domain admin accounts",
        "request": "MATCH (n{enabled:true}) WHERE n.is_da = TRUE RETURN n.domain AS domain, n.name AS name, n.da_types AS `admin type`",
        "output_type": "dict"
    },
    "os": {
        "name": "Number of OS",
        "request": "MATCH (c:Computer{enabled:true}) WHERE  NOT c.enabled IS NULL AND NOT c.operatingsystem IS NULL RETURN DISTINCT(c.operatingsystem) AS os, toInteger(($extract_date - c.lastlogontimestamp)/86400) as lastLogon, c.name AS name, c.domain AS domain ORDER BY c.operatingsystem",
        "output_type": "dict"
    },
    "krb_pwd_last_change": {
        "name": "Kerberos password last change in days",
        "request": "MATCH(u:User) WHERE u.name STARTS WITH \"KRBTGT@\" RETURN u.domain as domain, u.name as name, toInteger(($extract_date - u.pwdlastset)/86400) as pass_last_change, toInteger(($extract_date - u.whencreated)/86400) AS accountCreationDate",
        "output_type": "dict"
    },
    "nb_kerberoastable_accounts": {
        "name": "Number of Kerberoastable accounts",
        "request": "MATCH (u:User{hasspn:true,enabled:true}) WHERE u.name IS NOT NULL RETURN u.domain AS domain, u.name AS name, toInteger(($extract_date - u.pwdlastset)/86400) AS pass_last_change, u.is_da AS is_Domain_Admin, u.serviceprincipalnames AS SPN, toInteger(($extract_date - u.whencreated)/86400) AS accountCreationDate ORDER BY pass_last_change DESC",
        "output_type": "dict"
    },
    "nb_as-rep_roastable_accounts": {
        "name": "Number of AS-REP Roastable accounts",
        "request": "MATCH (u:User{enabled:true,dontreqpreauth: true}) RETURN u.domain AS domain,u.name AS name, u.is_da AS is_Domain_Admin",
        "output_type": "dict"
    },
    "nb_computer_unconstrained_delegations": {
        "name": "Number of machines with unconstrained delegations",
        "request": "MATCH (c2:Computer{unconstraineddelegation:true,is_dc:FALSE}) RETURN DISTINCT(c2.domain) AS domain,c2.name AS name",
        "output_type": "dict"
    },
    "nb_users_unconstrained_delegations": {
        "name": "Number of users with unconstrained delegations",
        "request": "MATCH (c2:User{enabled:true,unconstraineddelegation:true,is_da:FALSE}) RETURN DISTINCT(c2.domain) AS domain,c2.name AS name",
        "output_type": "dict"
    },
    "users_constrained_delegations": {
        "name": "Number of users with constrained delegations",
        "request": "MATCH (u:User)-[:AllowedToDelegate]->(c:Computer) WHERE u.name IS NOT NULL AND c.name IS NOT NULL RETURN u.name AS name, c.name AS computer,c.is_dc as to_DC ORDER BY name",
        "output_type": "dict"
    },
    "dormant_accounts": {
        "name": "Dormant accounts",
        "request": "MATCH (n:User{enabled:true}) WHERE toInteger(($extract_date - n.lastlogontimestamp)/86400)>$password_renewal RETURN n.domain as domain, n.name as name,toInteger(($extract_date - n.lastlogontimestamp)/86400) AS days, toInteger(($extract_date - n.whencreated)/86400) AS accountCreationDate ORDER BY days DESC",
        "output_type": "dict"
    },
    "password_last_change": {
        "name": "Password last change in days",
        "request": "MATCH (c:User {enabled:TRUE}) RETURN DISTINCT(c.name) AS user,toInteger(($extract_date - c.pwdlastset )/ 86400) AS days, toInteger(($extract_date - c.whencreated)/86400) AS accountCreationDate ORDER BY days DESC",
        "output_type": "dict"
    },
    "nb_user_password_cleartext": {
        "name": "Number of accounts where password cleartext password is populated",
        "request": "MATCH (u:User) WHERE NOT u.userpassword IS null RETURN u.name AS user,\"[redacted for security purposes]\" AS password, u.is_da as `is Domain Admin`",
        "output_type": "dict"
    },
    "get_users_password_not_required": {
        "name": "Number of accounts where password is not required",
        "request": "MATCH (u:User{enabled:true,passwordnotreqd:true}) RETURN DISTINCT (u.domain) as domain, (u.name) AS user,toInteger(($extract_date - u.pwdlastset )/ 86400) AS pwdlastset,toInteger(($extract_date - u.lastlogontimestamp)/86400) AS lastlogon",
        "output_type": "dict"
    },
    "objects_admincount": {
        "name": "N objects have AdminSDHolder",
        "request": "MATCH (n{enabled:True, admincount:True}) RETURN n.domain as domain, labels(n)[1] as type, n.name as name ",
        "output_type": "dict",
        "_comment": "FIXME: the UNION is messing up the AS and breaks the grid 'UNION MATCH (n{admincount:true}) RETURN n.domain as domain, labels(n)[1] as type, n.name as name',"
    },
    "user_password_never_expires": {
        "name": "Password never expired",
        "request": "MATCH (u:User{enabled:true})WHERE u.pwdneverexpires = true RETURN DISTINCT(u.domain) AS domain, u.name AS name, toInteger(($extract_date - u.lastlogontimestamp)/86400) AS LastLogin, toInteger(($extract_date - u.pwdlastset )/ 86400) AS LastPasswChange,toInteger(($extract_date - u.whencreated)/86400) AS accountCreationDate",
        "output_type": "dict"
    },
    "computers_members_high_privilege": {
        "name": "High privilege group computer member",
        "request": "MATCH(c:Computer{is_dc:false})-[r:MemberOf*1..4]->(g:Group{highvalue:true}) WHERE NOT c.name IS NULL RETURN distinct(c.name) AS computer, g.name AS group, g.domain AS domain",
        "output_type": "dict"
    },
    "objects_to_domain_admin": {
        "name": "Objects with path to DA",
        "request": "MATCH (m{path_candidate:true}) WHERE NOT m.name IS NULL WITH m ORDER BY m.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((m)-[r:$properties*1..$recursive_level]->(g:Group{is_dag:true})) WHERE m<>g SET m.has_path_to_da=true RETURN DISTINCT(p) as p",
        "output_type": "Graph",
        "scope_query": "MATCH (m{path_candidate:true}) WHERE NOT m.name IS NULL RETURN count(m)",
        "is_a_write_request": "true"
    },
    "objects_to_adcs": {
        "name": "Objects with path to ADCS servers",
        "request": "MATCH (o{path_candidate:true}) WHERE NOT o.name IS NULL WITH o ORDER BY o.name SKIP PARAM1 LIMIT PARAM2 MATCH p=(o)-[rrr:MemberOf*1..4]->(gg:Group)-[rr:AdminTo]->(c) WHERE c.is_adcs = TRUE RETURN DISTINCT(p) as p",
        "output_type": "Graph",
        "scope_query": "MATCH (m{path_candidate:true}) WHERE NOT m.name IS NULL RETURN count(m)"
    },
    "users_admin_on_computers": {
        "name": "Users admin on machines",
        "request": "MATCH p=(n:User{enabled:true})-[r:MemberOf|AdminTo*1..4]->(m:Computer) WHERE n:User AND n.enabled=true RETURN distinct(n.name) AS user,m.name AS computer,m.has_path_to_da AS has_path_to_da",
        "output_type": "dict"
    },
    "users_admin_on_servers_1": {
        "name": "Users admin on servers n\u00b01",
        "request": "MATCH p=(n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL MATCH (n)-[r:MemberOf*1..4]->(g:Group)-[r1:$properties]->(u:Computer) WITH LENGTH(p) as pathLength, p, n, u SKIP PARAM1 LIMIT PARAM2 WHERE NONE (x in NODES(p)[1..(pathLength-1)] WHERE x.objectid = u.objectid) AND NOT n.objectid = u.objectid RETURN n.name AS user, u.name AS computer, u.has_path_to_da as has_path_to_da",
        "scope_query": "MATCH (n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL RETURN count(n)",
        "output_type": "dict"
    },
    "users_admin_on_servers_2": {
        "name": "Users admin on servers n\u00b02",
        "request": "MATCH p=(n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL MATCH (n)-[r1:$properties]->(u:Computer) WITH LENGTH(p) as pathLength, p, n, u SKIP PARAM1 LIMIT PARAM2 WHERE NONE (x in NODES(p)[1..(pathLength-1)] WHERE x.objectid = u.objectid) AND NOT n.objectid = u.objectid RETURN n.name AS user, u.name AS computer, u.has_path_to_da as has_path_to_da",
        "scope_query": "MATCH (n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL RETURN count(n)",
        "output_type": "dict"
    },
    "computers_admin_on_computers": {
        "name": "Number of computers admin of computers",
        "request": "CALL{MATCH (c1:Computer)-[r1:AdminTo]->(c2:Computer) WHERE c1.name IS NOT NULL AND c2.name IS NOT NULL AND c1 <> c2 RETURN c1.name AS source_computer, c2.name AS target_computer, c2.has_path_to_da AS has_path_to_da UNION ALL MATCH (c1:Computer)-[r2:MemberOf*1..4]->(g:Group)-[r3:AdminTo]->(c2:Computer) WHERE c1.name IS NOT NULL AND c2.name IS NOT NULL AND c1 <> c2 RETURN c1.name AS source_computer, c2.name AS target_computer, c2.has_path_to_da AS has_path_to_da}  RETURN distinct(source_computer), target_computer, has_path_to_da",
        "output_type": "dict"
    },
    "domain_map_trust": {
        "name": "Domain map trust",
        "request": "MATCH p=shortestpath((d:Domain)-[:TrustedBy]->(m:Domain)) WHERE d<>m RETURN DISTINCT(p)",
        "request2": "MATCH p=(c1:Computer)-[r2:MemberOf*1..4]->(g:Group)-[r3:AdminTo]->(c2:Computer) RETURN p",
        "output_type": "Graph"
    },
    "objects_to_unconstrained_delegation": {
        "name": "Object with path to non-DC computers with unconstrained delegations ",
        "request": "MATCH (n{path_candidate:true}) WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((n)-[:$properties*1..$recursive_level]->(m:Computer{unconstraineddelegation:true,is_dc:false})) WHERE NOT n=m AND NOT m.name IS NULL RETURN DISTINCT(p)",
        "output_type": "Graph",
        "scope_query": "MATCH (n{path_candidate:true}) RETURN count(n)"
    },
    "users_to_unconstrained_delegation": {
        "name": "Objects with paths to users that have unconstrained delegations ",
        "request": "MATCH (n{path_candidate:true}) WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((n:User{is_da:false,enabled:true})-[:$inbound_control_edges*1..$recursive_level]->(m:User{unconstraineddelegation:true,enabled:true,sensitive:false})) WHERE NOT n=m AND NOT m.name IS NULL RETURN DISTINCT(p)",
        "output_type": "Graph",
        "scope_query": "MATCH (n{path_candidate:true}) RETURN count(n)"
    },
    "nb_computers_laps": {
        "name": "Number of computers with laps",
        "request": "MATCH (c:Computer) WHERE NOT c.name is NULL and NOT c.haslaps IS NULL AND c.operatingsystem CONTAINS 'indows' RETURN DISTINCT(c.domain) AS domain, toInteger(($extract_date - c.lastlogontimestamp)/86400) as lastLogon, c.name AS name, toString(c.haslaps) AS LAPS",
        "output_type": "dict"
    },
    "can_read_laps": {
        "name": "Objects allowed to read LAPS",
        "request": "MATCH p = (n)-[r1:MemberOf*1..]->(g:Group)-[r2:GenericAll]->(t:Computer {haslaps:true}) RETURN distinct(n.domain) AS domain, n.name AS name",
        "output_type": "dict"
    },
    "objects_to_dcsync": {
        "name": "Objects to dcsync",
        "request": "MATCH (n{path_candidate:true}) WHERE n.can_dcsync IS NULL AND NOT n.name IS NULL WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((n)-[r:$properties*1..$recursive_level]->(target{can_dcsync:TRUE})) WHERE n<>target RETURN distinct(p) AS p",
        "output_type": "Graph",
        "scope_query": "MATCH (n{path_candidate:true}) WHERE n.can_dcsync IS NULL AND NOT n.name IS NULL RETURN count(n)"
    },
    "dom_admin_on_non_dc": {
        "name": "Domain admin with session on non DC computers",
        "request": "MATCH p=(c:Computer)-[r:HasSession]->(u:User{enabled:true, is_da:true}) WHERE NOT c.name IS NULL and NOT u.name IS NULL and NOT c.is_dc=True RETURN distinct(p) AS p",
        "output_type": "Graph"
    },
    "unpriv_to_dnsadmins": {
        "name": "Unprivileged users with path to DNSAdmins",
        "request": "MATCH (u:User{path_candidate:true}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH p=(u)-[r:MemberOf*1..$recursive_level]->(g:Group{is_dnsadmin:true}) RETURN distinct(p) AS p",
        "output_type": "Graph",
        "scope_query": "MATCH (u:User{path_candidate:true}) RETURN count(u)"
    },
    "rdp_access": {
        "name": "Users with RDP-access to Computers ",
        "request": "CALL{MATCH p=(n:User{enabled:true,is_da:false})-[r1:MemberOf*1..5]->(m:Group)-[r2:CanRDP]->(c:Computer) RETURN n,c UNION ALL MATCH p=(n:User{enabled:true,is_da:false})-[r2:CanRDP]->(c:Computer) RETURN n,c }RETURN DISTINCT n.name AS user, c.name as computer",
        "output_type": "dict"
    },
    "dc_impersonation": {
        "name": "Non-domain admins that can directly or indirectly impersonate a Domain Controller ",
        "request": "CALL{MATCH p=(u{ou_candidate:true})-[r:MemberOf*1..5]->(g:Group)-[r3:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl]->(m:Computer{is_dc:true}) RETURN p UNION ALL MATCH p=(u{ou_candidate:true})-[r3:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl]->(m:Computer{is_dc:true}) RETURN p }RETURN DISTINCT p",
        "output_type": "Graph"
    },
    "rbcd": {
        "name": "RBCD attacks",
        "request": "CALL{MATCH (u:User{enabled:true,is_da:false}) WHERE u.name IS NOT NULL WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH (u:User{enabled:true,is_da:false})-[rr:MemberOf*1..5]->(g:Group)-[r:GenericAll|GenericWrite|WriteDACL|AllExtendedRights|Owns|AdminTo]->(m:Computer{is_server:true}) RETURN u as user, g.name as groupname, r, m UNION ALL MATCH (u:User{enabled:true,is_da:false}) WHERE u.name IS NOT NULL WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH (u:User{enabled:true,is_da:false})-[r:GenericAll|GenericWrite|WriteDACL|AllExtendedRights|Owns|AdminTo]->(m:Computer{is_server:true}) RETURN u as user, \"Direct (nogroup)\" as groupname, r, m }RETURN distinct user.name as username, groupname, type(r) as acl, m.name as computername ORDER BY username, computername, acl",
        "output_type": "dict",
        "scope_query": "MATCH (u:User{enabled:true,is_da:false}) RETURN count(u)"
    },
    "graph_rbcd": {
        "name": "Builds RBCD attack path graph and sets is_rbcd_target attribute ",
        "request": "CALL{ MATCH p1=(u:User{enabled:true,is_da:false})-[rr:MemberOf|AddMember*1..5]->(g:Group)-[r:GenericAll|GenericWrite|WriteDACL|AllExtendedRights|Owns|AdminTo]->(m:Computer{is_server:true}) SET m.is_rbcd_target=TRUE RETURN p1 as p UNION ALL MATCH p2=(u:User{enabled:true,is_da:false})-[r:GenericAll|GenericWrite|WriteDACL|AllExtendedRights|Owns|AdminTo]->(m:Computer{is_server:true}) SET m.is_rbcd_target=TRUE RETURN p2 as p } RETURN p",
        "output_type": "Graph",
        "is_a_write_request": "true"
    },
    "graph_rbcd_to_da": {
        "name": "Builds RBCD targets to DA paths",
        "request": "MATCH (m:Computer{is_rbcd_target:true}) WHERE NOT m.name IS NULL WITH m ORDER BY m.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((m)-[r:$properties*1..$recursive_level]->(g:Group{is_dag:true})) WHERE m<>g RETURN DISTINCT(p) as p",
        "output_type": "Graph",
        "scope_query": "MATCH (m:Computer{is_rbcd_target:true}) WHERE NOT m.name IS NULL RETURN count(m)"
    },
    "objects_to_ou_handlers": {
        "name": "paths to objects that can link a gpo on an OU",
        "request": "MATCH (u{ou_candidate:true}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH p1=shortestPath((u)-[:MemberOf|GenericAll|GenericWrite|Owns|WriteOwner|WriteDacl*1..8]->(o:OU{contains_da_dc:true})) WHERE NOT u=o CALL{WITH p1,o RETURN DISTINCT(p1) as p UNION ALL WITH o MATCH p=shortestPath((o:OU{contains_da_dc:true})-[:Contains*1..]->(v{is_da_dc:true})) RETURN DISTINCT(p) as p }RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (u:Computer{ou_candidate:true}) RETURN count(u)"
    },
    "vuln_functional_level": {
        "name": "Insufficient forest and domains functional levels. According to ANSSI (on a scale from 1 to 5, 5 being the better): the security level is at 1 if functional level (FL) <= Windows 2008 R2, at 3 if FL <= Windows 2012R2, at 4 if FL <= Windows 2016 / 2019 / 2022.",
        "request": "MATCH (o:Domain) WHERE o.functionallevel IS NOT NULL RETURN CASE WHEN toUpper(o.functionallevel) CONTAINS \"2000\" OR toUpper(o.functionallevel) CONTAINS \"2003\" OR toUpper(o.functionallevel) CONTAINS \"2008\" OR toUpper(o.functionallevel) CONTAINS \"2008 R2\" THEN 1 WHEN toUpper(o.functionallevel) CONTAINS \"2012 R2\" THEN 2 WHEN toUpper(o.functionallevel) CONTAINS \"2016\" OR toUpper(o.functionallevel) CONTAINS \"2018\" OR toUpper(o.functionallevel) CONTAINS \"2020\" OR toUpper(o.functionallevel) CONTAINS \"2022\" THEN 5 END as `Level maturity`, o.distinguishedname as `Full name`, o.functionallevel as `Functional level`",
        "output_type": "dict"
    },
    "vuln_sidhistory_dangerous": {
        "name": "Accounts or groups with unexpected SID history",
        "request": "MATCH(o1)-[r:HasSIDHistory]->(o2{is_da:true}) RETURN o1.domain as parent_domain, o1.name as name, o1.sidhistory as sidhistory",
        "output_type": "dict"
    },
    "can_read_gmsapassword_of_adm": {
        "name": "Objects allowed to read the GMSA of objects with admincount=True",
        "request": "CALL {MATCH (o{path_candidate:true}) WITH o ORDER BY o.name SKIP PARAM1 LIMIT PARAM2 MATCH p=((o)-[:MemberOf*1..7]->(g:Group)-[:ReadGMSAPassword]->(u:User{is_admin:true})) WHERE o.name<>u.name RETURN DISTINCT(p) UNION ALL MATCH (o{path_candidate:true}) WITH o ORDER BY o.name SKIP PARAM1 LIMIT PARAM2 MATCH p=((o)-[:ReadGMSAPassword]->(u:User{is_admin:true})) WHERE o.name<>u.name RETURN DISTINCT(p) } RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (o{path_candidate:true}) RETURN count(o)"
    },
    "objects_to_operators_member": {
        "name": "Unprivileged users with path to an Operator Member",
        "request": "MATCH (m:User{path_candidate:true}) WHERE NOT m.name CONTAINS \"MSOL_\" WITH m ORDER BY m.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((m)-[r:$properties*1..$recursive_level]->(o:User{is_operator_member:true})) WHERE m<>o AND NOT m.name CONTAINS \"MSOL_\" AND ((o.is_da=true AND o.domain<>m.domain) OR (o.is_da=false AND o.domain=m.domain)) RETURN DISTINCT(p) as p",
        "output_type": "Graph", 
        "scope_query": "MATCH (m:User{path_candidate:true}) WHERE NOT m.name CONTAINS 'MSOL_' RETURN count(m)",
        "_comment": "TODO: table with type, account name, is_da (star) and the number of path towards it"
    },
    "vuln_permissions_adminsdholder": {
        "name": "Dangerous permissions on the adminSDHolder object",
        "request": "MATCH (n:User{path_candidate:true}) WHERE NOT n.name CONTAINS \"MSOL_\" WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((n)-[r:$properties*1..4]->(target1{is_adminsdholder:true})) WHERE n<>target1 AND NOT ANY(no in nodes(p) WHERE (no.is_da=true AND (no.domain=target1.domain OR target1.domain CONTAINS \".\" + no.domain))) RETURN distinct(p) AS p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{path_candidate:true}) WHERE NOT n.name CONTAINS 'MSOL_' RETURN count(n)",
        "_comment": "TODO : table with les adminsdholder + path with => X objects to SDHolder"
    },
    "da_to_da": {
        "name": "Paths between two domain admins belonging to different domains",
        "request": "MATCH p=allShortestPaths((g:Group{is_dag:true})-[r:$properties*1..$recursive_level]->(gg:Group{is_dag:true})) WHERE g<>gg AND g.domain <> gg.domain RETURN p",
        "output_type": "Graph"
    },
    "group_anomaly_acl": {
        "name": "group_anomaly_acl",
        "request": "MATCH (gg:Group) WHERE EXISTS(gg.members_count) with gg as g order by gg.members_count DESC LIMIT 10000 MATCH (g)-[r2{isacl:true}]->(n) RETURN g.members_count,n.name,g.name, type(r2) order by g.members_count DESC",
        "output_type": "dict"
    },
    "get_empty_groups": {
        "name": "Returns empty groups",
        "request": "MATCH (g:Group) WHERE NOT EXISTS(()-[:MemberOf]->(g)) AND NOT g.distinguishedname CONTAINS 'CN=BUILTIN' RETURN g.name AS `Empty group`, COALESCE(g.distinguishedname, '-') AS `Full Reference`",
        "output_type": "dict"
    },
    "get_empty_ous": {
        "name": "Returns empty ous",
        "request": "MATCH (o:OU) WHERE NOT ()<-[:Contains]-(o) RETURN o.name AS `Empty Organizational Unit`, COALESCE(o.distinguishedname, '-') AS `Full Reference`",
        "output_type": "dict"
    },
    "has_sid_history": {
        "name": "Objects that have a SID History",
        "request": "MATCH (a)-[r:HasSIDHistory]->(b) RETURN a.name AS `Has SID History`, LABELS(a)[0] AS `Type_a`, b.name AS `Target`, LABELS(b)[0] AS `Type_b`",
        "output_type": "dict"
    },
    "unpriv_users_to_GPO_init": {
        "name": "Initialization request for GPOs [WARNING: If this query is too slow, you can use --gpo_low]",
        "request": "MATCH (n:User{path_candidate:true}) WHERE NOT n.name IS NULL AND NOT n.name CONTAINS \"MSOL_\" WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((n)-[r:MemberOf|AddSelf|WriteSPN|AddKeyCredentialLink|AddMember|AllExtendedRights|ForceChangePassword|GenericAll|GenericWrite|WriteDacl|WriteOwner|Owns*1..]->(g:GPO)) WHERE NOT n=g AND NOT g.name IS NULL RETURN p ",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{path_candidate:true}) WHERE NOT n.name IS NULL AND NOT n.name CONTAINS \"MSOL_\" RETURN count(n)",
        "postProcessing": "Neo4j.setDangerousInboundOnGPOs",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_user_enforced": {
        "name": "Compromisable GPOs to users (enforced)",
        "request": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink {enforced:true}]->(container2)-[r2:Contains*1..]->(n) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_user_not_enforced": {
        "name": "Compromisable GPOs to users (not enforced)",
        "request": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink{enforced:false}]->(container1)-[r2:Contains*1..]->(n) WHERE NONE(x in NODES(p) WHERE x.blocksinheritance = true AND LABELS(x) = \"OU\") RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_computer_enforced": {
        "name": "Compromisable GPOs to computers (enforced)",
        "request": "MATCH (n:Computer) WITH n ORDER BY n.name WITH n SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink {enforced:true}]->(container2)-[r2:Contains*1..]->(n) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:Computer) RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_computer_not_enforced": {
        "name": "Compromisable GPOs to computers (not enforced)",
        "request": "MATCH (n:Computer) WITH n ORDER BY n.name WITH n SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink{enforced:false}]->(container1)-[r2:Contains*1..]->(n) WHERE NONE(x in NODES(p) WHERE x.blocksinheritance = true AND LABELS(x) = \"OU\") RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:Computer) RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO": {
        "name": "Non privileged users to GPO",
        "request": "MATCH (g:GPO) WITH g ORDER BY g.name SKIP PARAM1 LIMIT PARAM2 OPTIONAL MATCH (g)-[r1:GPLink {enforced:false}]->(container1) WITH g,container1 OPTIONAL MATCH (g)-[r2:GPLink {enforced:true}]->(container2) WITH g,container1,container2 OPTIONAL MATCH p = (g)-[r1:GPLink]->(container1)-[r2:Contains*1..8]->(n1:Computer) WHERE NONE(x in NODES(p) WHERE x.blocksinheritance = true AND LABELS(x) = \"OU\") WITH g,p,container2,n1 OPTIONAL MATCH p2 = (g)-[r1:GPLink]->(container2)-[r2:Contains*1..8]->(n2:Computer) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (g:GPO) RETURN COUNT(g)",
        "_comment": "this is the normal version of the GPO request"
    },
    "cross_domain_local_admins":{
        "name": "Users that are local admins cross-domain",
        "request": "MATCH p1=(u{enabled:true})-[r:MemberOf*1..4]->(g:Group{is_admin:true})-[rr:AdminTo]->(c:Computer) WHERE c.ghost_computer IS NULL AND u.domain <> c.domain AND NOT c.domain CONTAINS u.domain WITH collect(distinct p1) as paths OPTIONAL MATCH q=(u{enabled:true})-[r:AdminTo]->(c:Computer) WHERE c.ghost_computer IS NULL AND u.domain <> c.domain AND NOT c.domain CONTAINS u.domain WITH paths + collect(distinct q) as allPaths UNWIND allPaths as p RETURN DISTINCT p",
        "output_type": "Graph"
    },
    "cross_domain_domain_admins":{
        "name": "Users that are domain admins cross-domain",
        "request": "MATCH p=(u{enabled:true})-[r:MemberOf*1..4]->(g:Group{is_da:true}) WHERE u.domain <> g.domain AND NOT g.domain CONTAINS u.domain return p",
        "output_type": "Graph"
    }
}
